#!/usr/bin/env python2.7

from os.path import dirname, join, isfile, realpath, relpath, split, sep, exists, splitext
from zipfile import ZipFile
import sys
sys.path.insert(0, 'buildlib/jinja2.egg')
sys.path.insert(0, 'buildlib')

from fnmatch import fnmatch
from re      import search
import tarfile
import os
import shutil
import subprocess
import time
import jinja2


# The extension of the android and ant commands.
if os.name == 'nt':
    ANDROID = 'android.bat'
    ANT = 'ant.bat'
else:
    ANDROID = 'android'
    ANT = 'ant'

# if ANDROIDSDK is on path, use android from this path
ANDROIDSDK = os.environ.get('ANDROIDSDK')
if ANDROIDSDK:
    ANDROID = os.path.join(ANDROIDSDK, 'tools', ANDROID)

curdir = dirname(__file__)

# Try to find a host version of Python that matches our ARM version.
PYTHON = join(curdir, 'python-install', 'bin', 'python.host')

BLACKLIST_PATTERNS = [
    # code versionning
    '^*.hg/*',
    '^*.git/*',
    '^*.bzr/*',
    '^*.svn/*',

    # pyc/py
    '*.pyc',
    '*.py',

    # temp files
    '~',
    '*.bak',
    '*.swp',
]

WHITELIST_PATTERNS = []

python_files = []
program_dir  = None


# Used by render.
environment = jinja2.Environment(loader=jinja2.FileSystemLoader(
    join(curdir, 'templates')))

java_provider_tmpl = '''// Autogenerated file by build.py, don't change!

package org.renpy.appwidgets;

import org.renpy.android.PythonWidgetProvider;
/*
 * Licensed under the MIT license
 * http://opensource.org/licenses/mit-license.php
 *
 * Copyright 2014 Sebastian Scholz <abestanis.gc@gmail.com> 
 */


public class %(java_name)sProvider extends PythonWidgetProvider {
    
    private final String  WIDGET_NAME  = "%(name)s";
    private final String  WIDGET_CLASS = "%(cls)s";
    private final Integer PROVIDER_ID  = %(id)s;
    
    @Override
    public String getWidgetName() {
        return WIDGET_NAME;
    }
    
    @Override
    public String getWidgetClass() {
        return WIDGET_CLASS;
    }
    
    @Override
    public int getProviderId() {
        return PROVIDER_ID;
    }
}
'''

def getallSubclasses(cls, top_level = False):
    subclasses = cls.__subclasses__()
    lst = []
    if len(subclasses) != 0:
        for c in subclasses:
            lst += getallSubclasses(c)
    if not top_level:
        lst.append(cls)
    return lst


def checkListType(lst, typ):
    '''>>> checkListType(lst, typ) -> True or False
    Checks if all elements of 'lst' are of
    the type 'typ'.
    
    e.g.:
    >>> checkListType([1, 2, 3, 4],   int)
    True
    >>> checkListType([1, 2, '3', 4], int)
    False
    '''
    return all([type(x) is typ for x in lst])


def findfreeName(path, name, ext):
    '''>>> findfreeName(path, name, ext) -> free_name
    Finds an unused filename in 'path' for a file
    'name' and it's extension 'ext' and returns it.
    '''
    i = 0
    while exists(path + sep + name + ext):
        if not exists(path + sep + name + str(i) + ext):
            print('[Warn ] ' +  path + sep + name + ext + '" already exists, chosing ' + name + str(i))
            name = name + str(i)
        i += 1
    return name


pic_src_paths = []
'''The paths to the originally source of all
pictures in the res/drawable folder.
'''

def store_pic(path):
    '''>>> store_pic(path) -> name
    Copies a picture located at the given path 'path'
    to the res\drawable folder, if it isn't already
    in there. Returns the name of the picture which
    can be stored in an xml file.'''
    path    = path.replace('/', sep).replace('\\', sep)
    if not exists(path):
        if exists(program_dir + sep + path):
            path = program_dir + sep + path
        else:
            print('[ERROR] Given path to picture does not exists: "' + path + '"!')
            sys.exit(-1)
    if path in pic_src_paths or program_dir + sep + path in pic_src_paths:
        name = splitext(split(path)[-1])[0]
    else:
        name, ext = splitext(split(path)[-1])
        name = findfreeName('res' + sep + 'drawable', name, ext)
        dest = 'res' + sep + 'drawable' + sep + name + ext
        print('[Info ] Copying image from "' + path + '" to "' + dest + '"...')
        shutil.copy(path, dest)
        pic_src_paths.append(path)
    return name


def cleanup(src_path, layout_path):
    '''>>> cleanup(src_path, layout_path)
    Cleans the src_path, the layout_path and the res/drawable
    path from unnecessary files.
    Warning:
    - Deletes every file in 'src_path' + '\org\renpy\appwidgets'!
    - Deletes every file except 'icon.png' and 'presplash.jpg'
      from res/drawable!
    - Deletes every file that ends with '_info.xml' or '_layout.xml'
      from 'layout_path' except 'widget_dflt_layout.xml'!
    '''
    src_path    = src_path.replace('\'', '\\\'')
    src_path   += sep + 'org' + sep + 'renpy' + sep + 'appwidgets'
    layout_path = layout_path.replace('\'', '\\\'')
    for file_name in os.listdir('res' + sep + 'drawable'):
        if file_name not in ['icon.png', 'presplash.jpg']:
            os.remove('res' + sep + 'drawable' + sep + file_name)
    
    for file_name in os.listdir(src_path):
        os.remove(src_path + sep + file_name)
    
    for file_name in os.listdir(layout_path):
        if (file_name.endswith('_info.xml') or file_name.endswith('_layout.xml')) and file_name != 'widget_dflt_layout.xml':
            os.remove(layout_path + sep + file_name)


def gather_widgets():
    '''>>> gather_widgets() -> widget_infos_dict
    Gets all information about defined widgets in
    the WidgetProvider.py file located at program_dir,
    checks and returns them.'''
    widgets = []
    widgetProvider = None
    try:
        widgetProvider = __import__('WidgetProvider', None, None, [''])
    except Exception, msg:
        print('Failed to import "WidgetProvider.py": %(msg)s' % {'msg': msg})
        sys.exit(-1)
    
    if not hasattr(widgetProvider, 'Widget'):
        print('[Warn ] WidgetProvider does not decleare any Widgets.')
        return []
    
    classes = getallSubclasses(widgetProvider.Widget, True)
    if len(classes) < 1:
        print('[Warn ] WidgetProvider does not declare any Widgets.')
        return []
    
    for widget in classes:
        widgets.append({
            'cls_name':      widget.__name__,
            'name':          widget.widget_name or widget.__name__,
            'java_name':     (widget.widget_name or widget.__name__).replace(' ', ''),
            'dflt_size':     widget.widget_dflt_size,
            'min_size':      widget.widget_min_size,
            'preview_image': widget.preview_image,
            'hard_update':   widget.hard_update,
            'layout':        widget.initial_layout,
            'lock_layout':   widget.initial_lock_layout,
            'resize_mode':   widget.resize_mode,
            'category':      widget.widget_category,
            'init_action':   widget.init_action,
        })
        for data in widget.sub_widgets:
            widgets.append({
                'cls_name':      widget.__name__,
                'name':          data['widget_name']         if data.has_key('widget_name')         else (widget.widget_name or widget.__name__) + str(id(data)), # We need another name here
                'java_name':     ((widget.widget_name or widget.__name__) + str(id(data))).replace(' ', ''),
                'dflt_size':     data['widget_dflt_size']    if data.has_key('widget_dflt_size')    else widget.widget_dflt_size,
                'min_size':      data['widget_min_size']     if data.has_key('widget_min_size')     else widget.widget_min_size,
                'preview_image': data['preview_image']       if data.has_key('preview_image')       else widget.preview_image,
                'hard_update':   data['hard_update']         if data.has_key('hard_update')         else widget.hard_update,
                'layout':        data['initial_layout']      if data.has_key('initial_layout')      else widget.initial_layout,
                'lock_layout':   data['initial_lock_layout'] if data.has_key('initial_lock_layout') else widget.initial_lock_layout,
                'resize_mode':   data['resize_mode']         if data.has_key('resize_mode')         else widget.resize_mode,
                'category':      data['widget_category']     if data.has_key('widget_category')     else widget.widget_category,
                'init_action':   data['init_action']         if data.has_key('init_action')         else widget.init_action,
            })
    
    print('[Info ] Checking provided widget data...')
    
    error_list   = []
    warn_list    = []
    
    for widget in widgets:
        # check the data
        widgetname = widget['name']
        
        if type(widget['dflt_size']) not in [tuple, list]:
            error_list.append('widget_dflt_size   : The given default size of ' + widgetname + ' is not a tuple or a list: ' + str(widget['dflt_size']) + ' ' + str(type(widget['dflt_size'])))
        elif not ((0 < len(widget['dflt_size']) < 3) or checkListType(widget['dflt_size'], int)):
            error_list.append('widget_dflt_size   : The given default size of ' + widgetname + ' is not a pair of / a single int: ' + str(widget['dflt_size']))
        
        if widget['min_size'] != None:
            if type(widget['min_size']) not in [tuple, list]:
                error_list.append('widget_min_size    : The given minimal size of ' + widgetname + ' is not a tuple or a list: ' + str(widget['min_size']) + ' ' + str(type(widget['min_size'])))
            elif not ((0 < len(widget['min_size']) < 3) or checkListType(widget['min_size'], int)):
                error_list.append('widget_min_size    : The given minimal size of ' + widgetname + ' is not a pair of / a single int: ' + str(widget['min_size']))
        
        if widget['preview_image'] != None:
            if type(widget['preview_image']) != str:
                error_list.append('preview_image      : The given preview image of ' + widgetname + ' is not a string: ' + str(widget['preview_image']) + ' ' + str(type(widget['preview_image'])))
            elif (not exists(widget['preview_image'])) and exists(program_dir + sep + widget['preview_image']):
                widget['preview_image'] = program_dir + sep + widget['preview_image']
            elif not exists(widget['preview_image']):
                warn_list.append('preview_image      : The given preview image of ' + widgetname + ', "' + widget['preview_image'] + '" does not exist. Using the default image instead.')
                widget['preview_image'] = None
        
        if type(widget['hard_update']) != int:
            error_list.append('hard_update        : The given update timer of ' + widgetname + ' is not an int: ' + str(widget['hard_update']) + ' ' + str(type(widget['hard_update'])))
        elif 0 < widget['hard_update'] < 1800000:
            warn_list.append('hard_update        : The given update timer of ' + widgetname + ' is too small: ' + str(widget['hard_update']) + '. Use the soft update method and set hard_update to 0, if you want to update more frequency. Setting the update time to minimum; 30 minutes (1800000 ms).')
            widget['hard_update'] = 1800000
        
        if widget['layout'] != None:
            if type(widget['layout']) != str:
                error_list.append('initial_layout     : The given initial layout of ' + widgetname + ' is not a string: ' + str(widget['layout']) + ' ' + str(type(widget['layout'])))
        
        if widget['lock_layout'] != None:
            if type(widget['lock_layout']) != str:
                error_list.append('initial_lock_layout: The given initial layout for the lock screen of ' + widgetname + ' is not a string: ' + str(widget['lock_layout']) + ' ' + str(type(widget['lock_layout'])))
        
        if widget['resize_mode'] == None:
            widget['resize_mode'] = 'none'
        elif type(widget['resize_mode']) != int:
            error_list.append('resize_mode        : Given resize mode of ' + widgetname + ' is not an int or None: ' + str(widget['resize_mode']) + ' ' + str(type(widget['resize_mode'])) + '\n[Note ] Use None, Widget.Resize_Horizontal, Widget.Resize_Vertical or Widget.Both!')
        elif not (-1 < widget['resize_mode'] < 4):
            error_list.append('resize_mode        : Given resize mode of ' + widgetname + ' is not one of None(0 or None), Widget.Resize_Horizontal(1), Widget.Resize_Vertical(2) or Widget.Both(3): ' + str(widget['resize_mode']))
        else:
            widget['resize_mode'] = ['none', 'horizontal', 'vertical', 'horizontal|vertical'][widget['resize_mode']]
        
        if type(widget['category']) != int:
            error_list.append('category           : Given resize mode of ' + widgetname + ' is not an int: ' + str(widget['category']) + ' ' + str(type(widget['category'])) + '\n[Note ] Use Widget.Category_Homescreen, Widget.Category_Lockscreen or Widget.Both!')
        elif not (0 < widget['category'] < 4):
            error_list.append('category           : Given resize mode of ' + widgetname + ' is not one of Widget.Category_Homescreen(1), Widget.Category_Lockscreen(2) or Widget.Both(3): ' + str(widget['category']))
        else:
            widget['category'] = ['ERROR', 'home_screen', 'keyguard', 'home_screen|keyguard'][widget['category']]
        
        if widget['init_action'] != None and type(widget['init_action']) not in [str, dict, bool]:
            error_list.append('init_action        : Given init action of ' + widgetname + ' is not a string, a dict, boolean or None: ' + str(widget['category']) + ' ' + str(type(widget['category'])))
    
    if len(error_list) != 0:
        for e in error_list:
            print('[ERROR] ' + e)
        print('[Info ] ' + str(len(error_list)) + ' error' + ('s' if len(error_list) > 1 else '') + ' occurred during read in of the WidgetProvider.py.')
        sys.exit(-1)
    
    if len(warn_list) != 0:
        for w in warn_list:
            print('[Warn ] ' + w)
        print('[Info ] ' + str(len(warn_list)) + ' warning' + ('s' if len(warn_list) > 1 else '') + ' occurred during read in of the WidgetProvider.py.')
        print('Press enter to continue or Ctrl + C to exit...')
        try:
            raw_input()
        except KeyboardInterrupt:
            sys.exit(-1)
    else:
        print('[Info ] All good!')
    
    return widgets


def build_widget_recources(widgets, src_path, layout_path):
    '''>>> build_widget_recources(widgets, src_path, layout_path)
    Create and copy all needed resources (WidgetProvider.java,
    images, widget_layout.xml, widget_lock_layout.xml,
    widget_info.xml) for the widgets described in the given
    dict 'widgets', using 'src_path' and 'layout_path'.'''
    print('[Info ] Building resources for the widgets...')
    src_path    = src_path.replace('\'', '\\\'')
    src_path   += sep + 'org' + sep + 'renpy' + sep + 'appwidgets'
    layout_path = layout_path.replace('\'', '\\\'')
    if not exists(src_path): # git doesn't sync empty dirs
        os.mkdir(src_path)
    
    # java provider
    
    for widget in widgets:
        provider = widget['java_name'] + 'Provider'
        print('[Info ] Building java widget provider for ' + widget['name'] + '...')
        provider = findfreeName(src_path, provider, '.java')
        widget['provider_name'] = provider
        print('[Info ] Writing to "' + src_path + sep + provider + '.java"...')
        f = open(src_path + sep + provider + '.java', 'w')
        f.write(java_provider_tmpl % {'java_name': widget['java_name'], 'name': widget['name'], 'cls': widget['cls_name'], 'id': str(id(widget))})
        f.close()
    
    # moving preview image
    
    pic_src_paths = []
    for widget in widgets:
        if widget['preview_image']:
            widget['preview_image'] = store_pic(widget['preview_image'])
    
    # init(lock)layout xml
    
    for widget in widgets:
        # Homescreen layout
        for typ in ['', 'lock_']:
            if widget[typ + 'layout']:
                layout = widget['java_name'].lower() + '_' + typ + 'layout'
                layout_str = widget[typ + 'layout']
                print('[Info ] Creating initial ' + ('home' if typ == '' else 'lock') + 'screen layout for ' + widget['name'] + ' at "' + layout_path + sep + layout + '.xml"...')
                res = search('android:src={{% ".*" %}}\n', layout_str)
                while res:
                    path = layout_str[res.start():res.end()][17:-6] # extract the path, removing 'android:src={{% "' and '" %}}\n'
                    print('[Debug] Found image that is required: ' + path)
                    path = store_pic(path)
                    layout_str = layout_str[:res.start() + 12] + '"@drawable/' + path + '"' + layout_str[res.end() - 1:]
                    res = search('android:src={{% ".*" %}}\n', layout_str)
                    
                
                print('[Info ] Writing to "' + layout_path + sep + layout + '.xml"...')
                f = open(layout_path + sep + layout + '.xml', 'wb')
                f.write('<?xml version="1.0" encoding="utf-8"?>\n' + layout_str)
                f.close()
                widget[typ + 'layout'] = layout
            else:
                if (typ == '' and 'home_screen' in widget['category']) or (typ == 'lock_' and 'keyguard' in widget['category']):
                    widget[typ + 'layout'] = 'widget_dflt_layout'
    
    # widgetinfo xml
    
    for widget in widgets:
        info = widget['java_name'].lower() + '_info'
        print('[Info ] Building AppWidgetProviderInfo xml (' + provider + ') for ' + widget['name'] + '...')
        info = findfreeName(layout_path, info, '.xml')
        widget['info_name'] = info
        print('[Info ] Writing from template to "' + layout_path + sep + info + '.xml"...')
        render(
            'AppWidgetProviderInfo.tmpl.xml',
            layout_path + sep + info + '.xml',
            widget=widget,
            android_api=int(os.environ.get('ANDROIDAPI', '8')),
        )


def render(template, dest, **kwargs):
    '''Using jinja2, render `template` to the filename `dest`, supplying the

    keyword arguments as template parameters.
    '''

    template = environment.get_template(template)
    text = template.render(**kwargs)

    f = file(dest, 'wb')
    f.write(text.encode('utf-8'))
    f.close()


def compile_dir(dfn):
    '''
    Compile *.py in directory `dfn` to *.pyo
    '''

    # -OO = strip docstrings
    subprocess.call([PYTHON, '-OO', '-m', 'compileall', '-f', dfn])


def is_whitelist(name):
    return match_filename(WHITELIST_PATTERNS, name)


def is_blacklist(name):
    if is_whitelist(name):
        return False
    return match_filename(BLACKLIST_PATTERNS, name)


def match_filename(pattern_list, name):
    for pattern in pattern_list:
        if pattern.startswith('^'):
            pattern = pattern[1:]
        else:
            pattern = '*/' + pattern
        if fnmatch(name, pattern):
            return True


def listfiles(d):
    basedir = d
    subdirlist = []
    for item in os.listdir(d):
        fn = join(d, item)
        if isfile(fn):
            yield fn
        else:
            subdirlist.append(os.path.join(basedir, item))
    for subdir in subdirlist:
        for fn in listfiles(subdir):
            yield fn


def make_pythonzip():
    '''
    Search for all the python related files, and construct the pythonXX.zip
    According to
    # http://randomsplat.com/id5-cross-compiling-python-for-embedded-linux.html
    site-packages, config and lib-dynload will be not included.
    '''
    global python_files
    d = realpath(join('private', 'lib', 'python2.7'))

    # selector function
    def select(fn):
        if is_blacklist(fn):
            return False
        fn = realpath(fn)
        assert(fn.startswith(d))
        fn = fn[len(d):]
        if (fn.startswith('/site-packages/') or
            fn.startswith('/config/') or
            fn.startswith('/lib-dynload/') or
            fn.startswith('/libpymodules.so')):
            return False
        return fn

    # get a list of all python file
    python_files = [x for x in listfiles(d) if select(x)]

    # create the final zipfile
    zfn = join('private', 'lib', 'python27.zip')
    zf = ZipFile(zfn, 'w')

    # put all the python files in it
    for fn in python_files:
        afn = fn[len(d):]
        zf.write(fn, afn)
    zf.close()


def make_tar(tfn, source_dirs, ignore_path=[]):
    '''
    Make a zip file `fn` from the contents of source_dis.
    '''

    # selector function
    def select(fn):
        rfn = realpath(fn)
        for p in ignore_path:
            if p.endswith('/'):
                p = p[:-1]
            if rfn.startswith(p):
                return False
        if rfn in python_files:
            return False
        return not is_blacklist(fn)

    # get the files and realpath file of all the directory we asked for
    files = []
    for sd in source_dirs:
        sd = realpath(sd)
        compile_dir(sd)
        files += [(x, relpath(realpath(x), sd)) for x in listfiles(sd)
                  if select(x)]

    # create tar.gz of those files
    tf = tarfile.open(tfn, 'w:gz')
    dirs = []
    for fn, afn in files:
        print '%s: %s' % (tfn, fn)
        dn = dirname(afn)
        if dn not in dirs:
            # create every dirs first if not exist yet
            d = ''
            for component in split(dn):
                d = join(d, component)
                if d.startswith('/'):
                    d = d[1:]
                if d == '' or d in dirs:
                    continue
                dirs.append(d)
                tinfo = tarfile.TarInfo(d)
                tinfo.type = tarfile.DIRTYPE
                tf.addfile(tinfo)

        # put the file
        tf.add(fn, afn)
    tf.close()


def make_package(args):
    version_code = 0
    manifest_extra = '<uses-feature android:glEsVersion="0x00020000" />'
    url_scheme = 'kivy'
    default_icon = 'templates/kivy-icon.png'
    default_presplash = 'templates/kivy-presplash.jpg'
    default_ouya_icon = 'templates/kivy-ouya-icon.png'
    
    # Figure out the version code, if necessary.
    if not args.numeric_version:
        for i in args.version.split('.'):
            version_code *= 100
            version_code += int(i)
        args.numeric_version = str(version_code)
    
    args.name = args.name.decode('utf-8')
    if args.icon_name:
        args.icon_name = args.icon_name.decode('utf-8')
    
    versioned_name = (args.name.replace(' ', '').replace('\'', '') +
                      '-' + args.version)
    
    # Android SDK rev14 needs two ant execs (ex: debug installed) and
    # new build.xml
    build_tpl = 'build.xml'
    
    if not args.icon_name:
        args.icon_name = args.name
    
    # Annoying fixups.
    args.name = args.name.replace('\'', '\\\'')
    args.icon_name = args.icon_name.replace('\'', '\\\'')
    
    # Figure out versions of the private and public data.
    private_version = str(time.time())
    
    if args.dir:
        public_version = private_version
    else:
        public_version = None
    
    if args.intent_filters:
        intent_filters = open(args.intent_filters).read()
    else:
        intent_filters = ''
    
    # Figure out if application has service part
    service = False
    directory = args.private or args.dir
    if directory:
        service_main = join(realpath(directory), 'service', 'main.py')
        if os.path.exists(service_main):
            service = True
    
    # Check if OUYA support is enabled
    if args.ouya_category:
        args.ouya_category = args.ouya_category.upper()
        if args.ouya_category not in ('GAME', 'APP'):
            print('Invalid --ouya-category argument. should be one of'
                  'GAME or APP')
            sys.exit(-1)
    
    # Get target android API
    android_api = int(os.environ.get('ANDROIDAPI', '8'))
    
    # Get widget information, if enabled
    widgets = []
    if args.widgets:
        # TODO: Cleanup appwidgets source path before adding the new classes
        widgets = gather_widgets() #FIXME: If a java widgetprovider class with same name allready exists, the file name will be changed but the class name will not, causing an error during compile
        build_widget_recources(widgets, 'src', 'res/layout')
    
    # Render the various templates into control files.
    render(
        'AndroidManifest.tmpl.xml',
        'AndroidManifest.xml',
        args           =  args,
        service        = service,
        url_scheme     = url_scheme,
        intent_filters = intent_filters,
        manifest_extra = manifest_extra,
        android_api    = android_api,
        widgets        = widgets)
    
    render(
        'Configuration.tmpl.java',
        'src/org/renpy/android/Configuration.java',
        args=args)
    
    render(
        build_tpl,
        'build.xml',
        args=args,
        versioned_name=versioned_name)
    
    render(
        'strings.xml',
        'res/values/strings.xml',
        public_version  = public_version,
        private_version = private_version,
        url_scheme      = url_scheme,
        args            = args)
    
    # Update the project to a recent version.
    try:
        subprocess.call([ANDROID, 'update', 'project', '-p', '.', '-t',
                         'android-{}'.format(android_api)])
    except (OSError, IOError):
        print 'An error occurred while calling', ANDROID, 'update'
        print 'Your PATH must include android tools.'
        sys.exit(-1)
    
    # Delete the old assets.
    if os.path.exists('assets/public.mp3'):
        os.unlink('assets/public.mp3')
    
    if os.path.exists('assets/private.mp3'):
        os.unlink('assets/private.mp3')
    
    # In order to speedup import and initial depack,
    # construct a python27.zip
    make_pythonzip()
    
    # Package up the private and public data.
    if args.private:
        make_tar('assets/private.mp3', ['private', args.private])
    else:
        make_tar('assets/private.mp3', ['private'])
    
    if args.dir:
        make_tar('assets/public.mp3', [args.dir], args.ignore_path)
    
    # Copy over the icon and presplash files.
    shutil.copy(args.icon or default_icon, 'res/drawable/icon.png')
    shutil.copy(args.presplash or default_presplash,
                'res/drawable/presplash.jpg')
    
    # If OUYA support was requested, copy over the OUYA icon
    if args.ouya_category:
        if not os.path.isdir('res/drawable-xhdpi'):
            os.mkdir('res/drawable-xhdpi')
        shutil.copy(args.ouya_icon or default_ouya_icon,
                    'res/drawable-xhdpi/ouya_icon.png')
    
    # If extra Java jars were requested, copy them into the libs directory
    if args.add_jar:
        for jarname in args.add_jar:
            if not os.path.exists(jarname):
                print 'Requested jar does not exist: {}'.format(jarname)
                sys.exit(-1)
            shutil.copy(jarname, 'libs')
    
    # Build.
    try:
        for arg in args.command:
            subprocess.check_call([ANT, arg])
    except (OSError, IOError):
        print 'An error occurred while calling', ANT
        print 'Did you install ant on your system ?'
        cleanup('src', 'res/layout')
        sys.exit(-1)
    finally:
        cleanup('src', 'res/layout')


if __name__ == '__main__':
    import argparse

    ap = argparse.ArgumentParser(description='''\
Package a Python application for Android.

For this to work, Java and Ant need to be in your path, as does the
tools directory of the Android SDK.
''')

    ap.add_argument('--package', dest='package',
                    help=('The name of the java package the project will be'
                          ' packaged under.'),
                    required=True)
    ap.add_argument('--name', dest='name',
                    help=('The human-readable name of the project.'),
                    required=True)
    ap.add_argument('--version', dest='version',
                    help=('The version number of the project. This should '
                          'consist of numbers and dots, and should have the '
                          'same number of groups of numbers as previous '
                          'versions.'),
                    required=True)
    ap.add_argument('--numeric-version', dest='numeric_version',
                    help=('The numeric version number of the project. If not '
                          'given, this is automatically computed from the '
                          'version.'))
    ap.add_argument('--dir', dest='dir',
                    help=('The directory containing public files for the '
                          'project.'))
    ap.add_argument('--private', dest='private',
                    help=('The directory containing additional private files '
                          'for the project.'))
    ap.add_argument('--launcher', dest='launcher', action='store_true',
                    help=('Provide this argument to build a multi-app '
                          'launcher, rather than a single app.'))
    ap.add_argument('--icon-name', dest='icon_name',
                    help='The name of the project\'s launcher icon.')
    ap.add_argument('--orientation', dest='orientation', default='landscape',
                    help=('The orientation that the game will display in. '
                          'Usually one of "landscape", "portrait" or '
                          '"sensor"'))
    ap.add_argument('--permission', dest='permissions', action='append',
                    help='The permissions to give this app.')
    ap.add_argument('--ignore-path', dest='ignore_path', action='append',
                    help='Ignore path when building the app')
    ap.add_argument('--icon', dest='icon',
                    help='A png file to use as the icon for the application.')
    ap.add_argument('--presplash', dest='presplash',
                    help=('A jpeg file to use as a screen while the '
                          'application is loading.'))
    ap.add_argument('--ouya-category', dest='ouya_category',
                    help=('Valid values are GAME and APP. This must be '
                          'specified to enable OUYA console support.'))
    ap.add_argument('--ouya-icon', dest='ouya_icon',
                    help=('A png file to use as the icon for the application '
                          'if it is installed on an OUYA console.'))
    ap.add_argument('--install-location', dest='install_location',
                    default='auto',
                    help=('The default install location. Should be "auto", '
                          '"preferExternal" or "internalOnly".'))
    ap.add_argument('--compile-pyo', dest='compile_pyo', action='store_true',
                    help=('Compile all .py files to .pyo, and only distribute '
                          'the compiled bytecode.'))
    ap.add_argument('--intent-filters', dest='intent_filters',
                    help=('Add intent-filters xml rules to the '
                          'AndroidManifest.xml file. The argument is a '
                          'filename containing xml. The filename should be '
                          'located relative to the python-for-android '
                          'directory'))
    ap.add_argument('--with-billing', dest='billing_pubkey',
                    help='If set, the billing service will be added')
    ap.add_argument('--blacklist', dest='blacklist',
                    default=join(curdir, 'blacklist.txt'),
                    help=('Use a blacklist file to match unwanted file in '
                          'the final APK'))
    ap.add_argument('--whitelist', dest='whitelist',
                    default=join(curdir, 'whitelist.txt'),
                    help=('Use a whitelist file to prevent blacklisting of '
                          'file in the final APK'))
    ap.add_argument('--sdk', dest='sdk_version', default='8',
                    help='Android SDK version to use. Default to 8')
    ap.add_argument('--minsdk', dest='min_sdk_version', default='8',
                    help='Minimum Android SDK version to use. Default to 8')
    ap.add_argument('--window', dest='window', action='store_true',
                    help='Indicate if the application will be windowed')
    ap.add_argument('--wakelock', dest='wakelock', action='store_true',
                    help=('Indicate if the application needs the device '
                          'to stay on'))
    ap.add_argument('command', nargs='*',
                    help=('The command to pass to ant (debug, release, '
                          'installd, installr)'))
    ap.add_argument('--add-jar', dest='add_jar', action='append',
                    help=('Add a Java .jar to the libs, so you can access its '
                          'classes with pyjnius. You can specify this '
                          'argument more than once to include multiple jars'))
    ap.add_argument('--meta-data', dest='meta_data', action='append',
                    help='Custom key=value to add in application metadata')
    ap.add_argument('--widget', dest='widgets', action='store_true',
                    help=('Enable the search for widgets. Each widgetclass in '
                          'the "WidgetProvider.py" gets his own category'))

    args = ap.parse_args()

    if not args.dir and not args.private and not args.launcher:
        ap.error('One of --dir, --private, or --launcher must be supplied.')

    if args.permissions is None:
        args.permissions = []

    if args.ignore_path is None:
        args.ignore_path = []

    if args.meta_data is None:
        args.meta_data = []

    if args.compile_pyo:
        if PYTHON is None:
            ap.error('To use --compile-pyo, you need Python 2.7.1 installed '
                     'and in your PATH.')
        BLACKLIST_PATTERNS += ['*.py', '*.pyc']

    if args.blacklist:
        with open(args.blacklist) as fd:
            patterns = [x.strip() for x in fd.read().splitlines() if x.strip()
                        and not x.startswith('#')]
        BLACKLIST_PATTERNS += patterns

    if args.whitelist:
        with open(args.whitelist) as fd:
            patterns = [x.strip() for x in fd.read().splitlines() if x.strip()
                        and not x.startswith('#')]
        WHITELIST_PATTERNS += patterns
    
    if args.widgets:
        if not exists(args.dir + sep + 'WidgetProvider.py'): # TODO: Improve for --private and --launcher
            ap.error('"' + args.dir + sep + 'WidgetProvider.py' + '" not found! For widgets a WidgetProvider must be supplied in the programs dir.')
        else:
            sys.path.append(args.dir)
            program_dir = args.dir
            if program_dir.endswith('/') or program_dir.endswith('\\'):
                program_dir = program_dir[:-1]
            

    make_package(args)
